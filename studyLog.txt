Part.1 springBoot 개요

23/11/19
1장 스프링 부트 시작하기

환경설정:
proejct : Gradle - Groovy
Language: Java
Spring Boot: 3.1.0
Packaging: Jar
Java: 17

빌드 실행하려는데 안되네.. jdk버전 문제인거같음...
쇼핑몰을 끝내구 다시해야하는건가...흠....
43페이지 그림 1-26 프로젝트 열기성공 여기서부터 해라 
-----------------------------------------------
23/11/20
쇼핑몰 잠정 중단이니, jdk17 그냥 깔자!
음..해결된듯? 그럼 해보자..

1장.
스프링부트의 개발 환경 설정은 3단계를 거친다. 먼저 JDK(Java Development Kit, 자바 개발도구) 설치한다.
JDK는 자바 코드의 번역과 실행을 담당한다. 다음으로 IDE(인텔리제이나, 이클립스, vs스튜디오 등등..)준비한다.
마지막으로 스프링 부트 프로젝트를 만들어 "헬로 월드!"를 띄우면 모든 준비가 끝이다. 

그럼 준비가 끝났으니, 포트번호는 8080이고... 로컬호스트 들어가보자 
크롬에서 localhost:8080 들어가보자.. 이거는 스프링 부트가 실행중인 프로젝트가 실행된 서버에 접속하라는 뜻이다.
근데 whitelabe error page가 뜰것이다 왜 그러냐 ?

에러 화면이 뜨는거는 아직 웹 페이지를 만들지 않았기 때문이다. 여기에 "헬로 월드!"가 나올 수 있게 HTML을 만들어보겠다. 
파일명은 hello.html이라고 한다. 이 파일을 만들었다고 가정했을 때 주소 표시줄에 localhost:8080/hello.html이라고 입력하면
"헬로 월드!"가 나온다. 물론 아직은 에러페이지가 뜨지만. 

그럼 hello.html을 만들어보자. 프로젝트 탐색기의 src > main > resources > static 디렉토리에서 html파일 하나 생성한다. 
이름은 hello.html 그럼 바디태그안에 h1태그를 넣어서 헬로 월드!를 입력해보자.

그런 다음 localhost:8080/hello.html 해보자. 여전히 안된다. 이는 새로 만든 HTML파일을 서버에서 반영하지 않아서 그런거다. 
서버를 다시 한번 run하자 ! 그럼 된다. 
웹서비스는 클라이언트의 요청에 따른 서버의 응답으로 동작한다. 여기서 클라이언트란 서비스를 사용하는 컴퓨터를 말하고, 
서버는 서비스를 제공하는 컴퓨터를 말한다. "헬로 월드!"도 클라이언트의 요청에 따른 서버의 응답 결과였다. 웹 브라우저가
클라이언트로서 동작하고, 스프링 부트는 서버 역할을 수행했다. 클라이언트의 요청에 응답하려면 당연히 서버가 실행 중이어야 한다. 
서버 중지하면 당연히 응답하지 않는다. 

localhost:8080/hello.html 
서버에 접속할 때 사용하는 localhost:8080의 의미는 무엇일까? 또 그 뒤에 붙이는 hello.html은 어떻게 해석될까? 하나씩 살펴보자.

localhost : 실행 중인 서버의 주소 중 특별한 주소인 '내 컴퓨터'를 의미한다. 마치 내가 사는 집을 '우리 집'이라고 표현하는것과 같다.
localhost를 ip주소로 변경하면 127.0.0.1이된다.

8080: 포트번호를 의미한다. localhost가 우리집 이라면 8080은 방 번호에 해당한다. 클라이언트가 8080 번 방에 뭔가를 요청하는거다.
그리고 8080번 안에는 스프링 부트가 동작하고 있다. 앞에서 서버를 실행했을 때 "Tomcat started on port(s): 8080.. 이라는 메세지를
봤을 것이다. 톰캣이 8080 포트 안에서 수행되고 있다는 뜻이다. 톰캣은 웹 서버를 말하는데, 스프링 부트는 이 톰캣에 담겨 실행된다. 
참고로 스프링 부트는 8080에서 기본 실행된다. 포트번호는 필요에따라 변경 가능하다.

hello.html: localhost:8080으로만 접속하면 에러 페이지가 뜬다. 그 뒤에 hello.html을 붙여 접속해야 원하는 화면을 볼 수있다.
이는 웹 브라우저에서 요청한 hello.html 파일을 스프링 부트가 응답으로 보여줬기 때문이다.

여기서 hello.html은 서버에 요청하는 파일을 말한다. 웹 브라우저에서 localhost:8080/hello.html로 접속하면 내 컴퓨터의 8080번에서
수행되는 서버에 hello.html 파일을 요청한다. 이렇게 파일을 직접 지정할 경우 스프링 부트는 기본적으로 src > main > resources > static
디렉토리에서 파일을 찾는다. 그리고 찾은 HTML 코드를 응답으로 보낸다. 


그 다음 2장. 
MVC 패턴 이해와 실습에 대해 알아보자.
웹 페이지를 하나의 틀로 보고 변수에 따라 서로 다르게 출력하는 뷰 템플릿을 만들어 본다. 
그리고 뷰 템플릿을 실행하기 위해 역할을 분담해 동작하는 기법인 MVC패턴에 대해서도 알아보자.

보통 웹 사이트에 로그인 하면 "OO님 반갑습니다." 라는 문구를 볼 수 있다. 이런 문구는 어떻게 표시할까? 사용자 수만큼 웹 페이지가 
있는걸까? 만약 그렇다면 굉장히 귀찮을것이다. 새로운 사용자가 가입할 때마다 매번 새로운 웹 페이지를 만들어 줘야하니..

이런 괴로움에서 벗어나고 싶던 개발자들은 뷰 템플릿이란 기술을 만든다. 뷰 템플릿(view template)은 화면을 담당하는 기술로 , 
웹 페이지(view)를 하나의 틀로 만들고 여기에 변수를 삽입해 서로 다른 페이지로 보여준다. 

MVC패턴이란? 화면을 담당하는 뷰 템플릿은 간단히 '뷰'라고 한다. 뷰는 컨트롤러와 모델이라는 두 동료가 있다. 컨트롤러는 클라이언트의
요청에 따라 서버에서 이를 처리하는 역할을 하고, 모델은 데이터를 관리하는 역할을 한다. 이처럼 웹 페이지를 화면에 보여주고 (view), 
클라이언트의 요청에 받아 처리하고(controller), 데이터를 관리하는(model)역할을 나누는 기법을 MVC패턴 이라고 한다. 
Model-View-Control Pattern

뷰 템플릿 함 만들어보자.
src > main > resources를 펼치면 static과 templates가 있다. 뷰 템플릿은 templates디렉토리에 만들면 된다.
greetings.mustache로 만들자. src > main > resources > templates에 저장하면 스프링부트에서 자동으로 로딩한다.

TIP) 템플릿 엔진으로는 mustache, Thymeleaf, JSP 등이 있다. 

greetings.mustache라는 html파일 하나 만들었다. 이 페이지를 웹에서 보려면, 바로 뷰 템플릿의 동료인 컨트롤러와 모델을 이용해야한다.

controller 패키지 생성 후 -> FirstController 생성

package com.example.firstproject.controller;

// 컨트롤러 선언과 동시에 자동으로 임포트 됨.
import org.springframework.stereotype.Controller;

@Controller
// 이 클래스가 컨트롤러임을 선언하는 @Controller 어노테이션 작성한다. 이렇게 하면 Controller 클래스 패키지
// 가 자동으로 임포트 된다. 위에 있음.
public class FirstController {

    // 반환형이 문자열인 niceToMeetYou() 메서드를 선언한다.
    public String niceToMeetYou() {
        // 그리고 공백 문자열("")을 반환 하도록 return ""; 문을 추가한다. 이 반환문을 이용해 앞에서 만든
        // greetings.mustache 페이지를 반환하겠다.greetings.mustache 페이지를 반환하려면 파일 이름인 greetings
        // 만 반환값으로 적어주면 된다. 즉 return "greetings";로 적어 주면 서버가 알아서 templates 디렉토리에서
        // greetings.mustache 파일을 찾아 웹 브라우저로 전송한다.

        return "greetings"; // greetings.mustache 파일 반환
    }
}

여기까지 잘 했으면, 서버 다시 실행하자! 그리고 localhost:8080/greetings 했는데, 다시 화이트라벨 에러난다.
왜그럴까? FirstController에 가보면 niceToMeetYou() 메서드가 greetings.mustache를 반환하기 위해 return greetings;라고썼다.
그런데 빠진게 하나있다. 페이지(greetings.mustache)를 반환해 달라는 URL 요청을 접수하는 부분이다. -> @GetMapping

niceToMeetYou()메서드 앞에 @GetMapping을 추가한다. 그러면 자동으로 겟매핑 패키지가 임포트 된다.
겟매핑 주소안에는 /hi 주소를 넣어준다. @GetMapping("/hi")

다음, 모델 추가하기

앞에서 출력한 "홍팍님, 반갑습니다!" 에서 '홍팍'을 다른이름으로 바꾸고 싶다면 어떻게 해야하나?
예를들어 '홍팍' 대신 username이라는 변수를 써서, 어떨때는 '홍팍', 어떨때는 '홍어삼함' 이라고 나오게 만드는거.

이럴 땐 머스테치 문법을 사용해 뷰 템플릿 페이지에 변수를 삽입한다. 변수명을 적고 두 겹의 중괄호 ({{}})로 감싼다.

cf) {{변수명}}

greetings.mustache에서 홍팍님을 {{username}}님 이라고 수정한다. 이렇게 이름 대신 들어갈 변수명을 쓰면 변숫값에 따라
결과가 그때그때 다르게 출력된다. 단순히 "홍팍님, 반갑습니다!" 라고 출력됐던 뷰 페이지가 "OO님, 반갑습니다!"로 템플릿화 되는거다.

서버 재시작하고 localhost:8080/hi에 접속해봐라. 그럼 내부에서 에러가 난다. 추가한 username이라는 변수를 찾을수 없기 때문이다.
에러를 해결하기 위해 모델을 사용하겠다! 모델은 MVC 패턴에서 데이터를 관리하는 역할을 한다.

모델은 컨트롤러의 메서드에서 매개변수로 받아온다. FirstController로 가서 niceToMeetYou() 메서드에 Model 타입의 model 매개변수를
추가해라. 그러면 Model 클래스 패키지가 자동으로 임포트 된다.

그 다음 Model 클래스 패키지가 임포트 됐다면, 모델을 통해 변수를 등록 할 수 있다. 모델에서 변수를 등록할 때는 addAttribute() 메서드를
사용.

 model.addAttribute("username", "홍어삼합"); -> 입력하고 다시 서버 재실행하고 브라우저 봐라.
잘 출력됨.

지금까지 한거 정리!

뷰 페이지 만들기 (greetings.mustache) -> 컨트롤러 만들기 (FirstController.java) -> 컨트롤러에서 뷰 페이지 반환하기 (return "greetings";)
-> 뷰 페이지에 변수 삽입하기 {{username}} -> 컨트롤러에 모델 추가하기 niceToMeetYou(Model model) -> 모델에서 변수 등록하기 model.addAttribute("username", "홍팍");

그 다음 MVC의 역할과 실행 흐름 이해하기

웹 서비스는 클라이언트의 요청에 대한 서버의 응답으로 동작한다. 이때 스프링 부트는 서버의 역할을 한다.
서버는 앞에서 배웠듯이 모델,뷰,컨트롤러가 유기적으로 역할을 분담해 클라이언트의 요청을 처리한다. 식당에서 웨이터가 주문을 받고, 주방장이 요리를 하고,
식재료 담당자가 재료를 준비하는 것처럼 컨트롤러가 클라이언트의 요청을 받고, 뷰가 최종 페이지를 만들고, 모델이 최종 페이지에 쓰일 데이터를 뷰에 전달한다.

앞에서 뷰 템플릿 페이지 (greetings.mustache)가 어떤 과정을 거쳐 출력되는지 알아봤으니 이번에는 모델, 뷰, 컨트롤러 관점에서 그 과정을 분석해보자.

아까 /hi 페이지의 실행 흐름.
localhost:8080/hi에 접속해 결과를 다시 한번 확인해 봅시다. "hongpark님, 반갑습니다!"가 잘 출력 된다. 이렇게 클라이언트가 localhost:8080/hi라고 요청하면
서버 내부에서는 컨트롤러가 요청을 받아 처리한다.

FirstController.java 코드를 보며 컨트롤러의 동작을 이해해보자. (책 89쪽 오늘 여기까지 낼 90패이지부터)
-----------------------------------------------
23/11/21 90p 시작.

이번에는 /bye 페이지를 만들어보자.
localhost:8080/bye로 요청을 받을 때, "XX님, 다음에 또 만나요!"를 출력해보겠다. /bye 요청을 받아 줄 컨트롤러를 새롭게 만들어도
되지만, 이번에도 그냥 FirstController를 사용해 보겠다.

1. 컨트롤러는 @Controller 내부에 @GetMapping 어노테이션을 통해 클라이언트의 요청을 받는다.
2. /bye 요청을 처리할 seeYouNext() 메서드를 만든다.
3. 반환값은 요청에 따라 보여 줄 뷰 템플릿 페이지를 적는데, 아직 뷰 템플릿 페이지를 만들지 않았으므로, 임의로 return "goodbye";라고 적음.
4. 그런데 사용자 이름을 그때그때 변경하고 싶다. XX님 부분을 변수로 처리해보자. 아까 했던것 처럼!! 변수명은 nickname으로 한다.
<h1>{{nickname}}님, 다음에 또 만나요!<h1>으로 코드를 수정한다.
5. 뷰 템플릿 페이지에서 변수(nickname)를 이용하려면 이 페이지를 반환하는 컨트롤러의 메서드 (seeYouNext)에 변수를 등록해야함.
모델을 통해서, 컨트롤러로 가서 다음과 같이 코드를 추가한다.
(1) seeYouNext() 메서드의 매개변수로 model 객체를 받아 온다.
(2) model.addAttribute() 메서드로 등록할 변수명과 변숫값을 적어준다.

정리하자면 컨트롤러는 클라이언트의 요청을 @GetMapping("/bye")로 받는다. 그리고 return값으로 goodbye.mnustache를 반환한다.
이때 "nickname" 이라는 변수를 등록하고, "홍길동" 이라는 값을 연결해 goodbye.mustache 파일에서 사용할 수 있게 한다.

이렇게 해서 /hi 페이지와 /bye 페이지의 출력 과정에서 모델, 뷰, 컨트롤러의 역할과 실행 흐름을 살펴봤다.

/hi , /bye 페이지에 헤더-푸터 레이아웃을 적용해보자. 좀 꾸며야 할꺼 아이가

bootstrap으로 활용해보겠다. v5.0.2로 해라.
Starter Template내용 다 복사해서 greetings.mustache에 다 붙여넣음.
body태그안에
navigation, content, site info 순으로 주석 달아서 적어줌.
콘텐트 영역을 만들었으니 헤더 영역에 네비게이션 바를 추가해보자! 부트스트랩 홈페이지가서 다시 v5.0.2짜리 검색창에서 navbar를 검색!

일단 간단하게 적용했다.
/hi는 끝 그담에 /bye까지 하고 오늘 끝내자.
/hi랑 똑같이 해주는거야 고고

헤더, 푸터 영역을 변수화해 사용해보도록 한다. 각각 영역을 발췌해 템플릿 파일로 만들자.
코드의 가독성이 훨씬 좋다.

templates > layouts > footer.mustache, header.mustache 각각 만들어라.
greetings.mustache 코드에서 상단 내비게이션 바 부분을 발췌해 header.mustache로 만들어보자.
1행부터 콘텐트 영역의 바로 윗줄 <!DOCTYPE HTML>~</nav>까지 선택해 자른 후 header.mustache 파일에 붙인다.
1행의 <!DOCTYPE HTML>~</nav>까지 잘 붙여넣었는지 확인한다.

마찬가지로 greetings 코드의 푸터영역 <!-- site info -->~</html>도 잘라낸 후 footer.mustache 파일에 붙여넣자.

greetings.mustache 코드의 컨텐트 영역 아래에 {{>layouts/footer}}를 작성해 템플릿화한 footer.mustache 파일을 변수로 가져오자.

최종적으로 greetings.mustache 코드가 매우 짧아졌다. 위쪽에 헤더파일이 아래쪽에 푸터 파일이 들어가있다.
이제 이 페이지를 보는 사람도 "여기서 핵심 내용(content)이 뭐야?" 라는 질문에 답할 수 있다. 딱 4줄짜리 코드만 보니까
아~ 인사하는 페이지구나 한다.

이렇게 해서 머스테치 뷰 템플릿으로 레이아웃을 구성해봤다. 결과가 잘 나오는지 확인해보자. 다시 로컬호스트 새로고침 해서
확인해보자. -> 잘됐다.

goodbye.mustache 파일도 다음과 같이 해라.

1. 콘텐트 영역 h1태그를 제외하고 기존 코드를 지운 후 헤더 템플릿과 푸터 템플릿을 삽입한다.
2. 콘텐트 영역을 div로 감싸고 부트스트랩의 class속성을 적용해 완성한다.

똑같이 잘됐다. 대단한데 ?

마무리.

1. 뷰 템플릿 : 웹 페이지를 하나의 틀로 만들고, 여기에 변수를 삽입해 서로 다른 페이지로 보여주는 기술
2. MVC 패턴 : 웹 페이지를 화면에 보여 주고(view), 클라이언트의 요청을 받아 처리하고(Controller), 데이터를 관리하는(Model) 역할을
영역별로 나누어 하는 기법을 말한다.
3. 뷰 템플릿 생성 위치
뷰 템플릿은 src > main > resource > templates 디렉토리에 만든다. 머스테치 뷰 템플릿의 확장자는 .mustache다.
4. 컨트롤러 생성 위치 : 컨트롤러는 src > main > java > 기본 패키지안에 컨트롤러 패키지를 만든 후 자바 클래스 파일을 생성하는 방식이다.
확장자는 .java다
5. 모델에 변수를 등록하는 방법 : 모델은 컨트롤러의 메서드에서 매개변수로 받아온다. 모델에서 변수를 등록할 때는 addAttribute() 메서드를 사용.
6. 헤더-푸터 레이아웃 : 가장 기본이 되는 페이지의 레이아웃으로 헤더 영역에는 사이트 안내를 위한 내비게이션을 넣고, 푸터 영역에는 사이트 정보등을
넣는다. 그리고 두 영역 사이에 콘텐트 영역에는 사용자가 볼 핵심 내용을 배치한다.
7. 부트스트랩 : 웹 페이지를 쉽게 만들 수 있도록 각종 레이아웃, 버튼, 입력창 등 디자인을 미리 만들어 놓은 것이다. 사용자는 코드를 가져와
사용하기만 하면 되므로 편리하게 웹 페이지를 만들 수 있다.
8. 레이아웃 템플릿 생성과 적용 : 레이아웃 템플릿 파일은 src > main > resource > templates 디렉토리에 만든다. (본문에서는 파일 관리를 편리하게
하기 위해 layouts 디렉토리를 추가한 후 만든다.)
**중요** 레이아웃 템플릿을 삽입할 때는 원하는 위치에서 {{>파일경로/파일명}} 형식으로 작성!

Part1. 스프링 부트 개요 끝! 생각보다 빨랐다. 하루만에 끝
---------------------------------------------------------------------------------------------------------

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
Part.2 게시판 CRUD 만들기

23/11/22
3장. 게시판 만들고 새 글 작성하기 시작하면된다.
책 기준 117쪽..

아까는 뷰 템플릿을 만들고 MVC 패턴에 따라 출력하는걸 연습했다. 앞으로 배울 3~8장에는 간단한 게시판을 만들며 데이터로 CRUD 하는방법 알아본다.
CRUD란 게시글을 생성하고 (Create) 조회하고 (Read) 수정하고 (Update) 삭제하는 (Delete) 것을 말한다. 게시판 만들기를 배우면
서버 프로그래밍과 데이터베이스의 기본기를 자연스럽게 익힐 수 있다. 굉장히 중요하다고 본다. 그럼 시작해본다.

3.1
폼 데이터(Form data)란

HTML 요소인 <form> 태그에 실려 전송되는 데이터를 말한다. 다들 인터넷 게시판에 글을 써본적이 있을것이다.
내용을 입력하고 [전송] 버튼을 눌리면 게시글이 올라가는데, <form> 태그는 이렇게 웹 브라우저에서 서버로 데이터를 전송할 때 사용.

<form> 태그는 택배에 비유할 수 있다. 택배를 보낼 때 송장에 수령자와 배송 형태(익일 배송, 새벽 배송 등)를 적는다. <form> 태그도
데이터를 전송할 때 어디로 (where), 어떻게 (how) 보낼지 등을 적어서 보낸다.

<form> 태그에 실어 보낸 데이터는 서버의 컨트롤러가 객체에 담아 받는다. 이 객체를 DTO(Data Transfer Object)라고 한다.
DTO로 받은 데이터는 최종적으로 데이터베이스에 저장된다. 다음 절에서는 간단한 입력 폼을 만들고 입력 폼 데이터를 서버로 보내
컨트롤러에서 확인하는 것까지 해보자.

3.2
폼 데이터를 DTO로 받기

3.2.1
입력 폼 만들기
뷰 템플릿 페이지에 입력 폼을 만들겠다. 뷰 템플릿 페이지는 지난번에도 했듯, templates 디렉토리에 만들어주면 된다.

1. src > main > resources > templates에서 articles 디렉토리를 하나 만든다. 그리고 그 안에 new.mustache 뷰 페이지 생성.
<form>태그를 작성하고 게시판의 제목을 입력할 <input>태그, 내용을 입력할 <textarea>태그, 전송버튼인 <button>태그를 추가하고
버튼의 속성을 type="submit"으로 설정한다.

2. 2장에서 만들었던 header와 footer 코드도 추가한다. 위쪽, 아래쪽에 각각 {{>layouts/header}}, {{>layouts/footer}} 추가.

3.2.2
컨트롤러 만들기
앞에서 작성한 페이지를 웹 브라우저에서 보기 위해 컨트롤러를 만들겠다.

1. 2장에서 만든 src > main > java > com.example.firstproject > controller 패키지에서 ArticleController를 만든다.

2. 그 다음에 코딩을 좀 한다.
①@Controller를 입력해 이 파일이 컨트롤러 임을 선언한다.

②뷰 페이지를 보여주기 위해서 newArticleForm() 메서드를 추가하고 반환값으로 뷰 페이지의 이름을 적는다(리턴 값) 이때
articles 이렉터리를 만들고 new.mustache 뷰페이지를 추가 했으므로 파일 경로까지 포함해 return "articles/new";라고 입력.

③URL 요청을 접수한다. localhost:8080/article/new에 뷰 페이지를 반환할 수 있도록 @GetMapping("article/new")라고 입력.

실행은 되는데 화면이 전혀 안예쁘다... 부트스트랩 CSS 코드로 이 부분에 디자인을 적용해보자.
new.mustache 파일의 <form></form> 태그 부분을 다음과 같이 수정한다. 이 코드는 <input>태그와 <textarea> 태그의 디자인 요소만
바꾼 것이다. 여기서는 폼 데이터를 전송하는 실습이 목적이므로 CSS 코드에 관한 자세한 설명은 생략.
-----------------------------------------------
23/11/23
다시한다. 127부터

3.2.3 폼 데이터 전송
①localhost:8080/articles/new 들어가보면 부트스트랩 적용 되어있다. 근데 submit눌러도 아무 소용 없다.
<form>태그를 입력할 때 2가지 정보(데이터를 어디로, 어떻게 보낼지에 대한 정보)를 주지 않았기 때문이다.

②<form>태그에 이 2가지 정보를 추가 해보겠다. 어디에 보낼지는 action속성, 어떻게 보낼지는 method속성으로 설정한다.

action: URL연결 주소를 적어 action"/articles/create"로 설정, localhost:8080/articles/create 페이지로 폼 데이터를 보낸다는 의미.
method: 속성 값으로 get과 post, 2가지를 설정할 수 있다. 여기서는 method="post" 방식으로 설정한다. 두 방식의 차이는 나중에 설명.

3.2.4 폼 데이터 받기
action, method 속성 정보를 설정했으니 서버의 컨트롤러가 이 정보를 조합해서 사용자가 전송한 폼 데이터를 받도록 한다.
ArticleController를 열고 다음과 같이 수정
① 컨트롤러에 createArticle() 메서드를 추가하고 형식을 맞추기 위해 return값에는 빈 문자를 적는다.
② 그 다음 URL 요청을 받아야하는데, 여기서는 @PostMapping을 사용한다. 뷰 페이지에서 폼 데이터를 post방식으로 전송했으므로,
컨트롤러에서 받을 때도 @PostMapping()으로 받는다. 이떄 괄호 안에는 받은 URL 주소를 넣는다. new.mustache에서
<form>태그에 action="/articles/create"로 설정했으므로  @PostMapping("/articles/create")작성.

3.2.5 DTO 만들기
앞서 컨트롤러에서 폼 데이터를 받을 때 DTO(Data Transfer Object)에 담는다고 배웠으니 DTO를 배워보자.
① DTO를 작성하기 위해 새 피키지를 만들자. com.example.firstproject에 dto 패키지 추가.
② 여기에 ArticleForm.java 하나 더 생성해서 dto 패키지에 클래스 추가해라.
③ 입력 폼에서 제목과 내용을 전송할 예정이니 DTO에도 2개의 필드가 필요하다. 필드 2개 title과 content를 선언
④ content 필드 다음 행에서 마우스 오른쪽을 누르고 Generate -> Constructor를 선택한다. 컨트롤키를 누른채
title:String과 content:String을 선택한 후 OK를 눌리면 자동으로 생성자가 추가된다.
⑤ 폼 데이터를 잘 받은지 확인하기 위해 toString()메서드를 추가하겠다. ArticleForm() 메서드 아래 행에서 마우스 오른 쪽 버튼을
누르고 Generate -> toString()을 선택. title:String과 content:String이 선택된 것을 확인하고 OK버튼을 클릭하면 toString()
메서드가 추가된다.

3.2.6 폼 데이터를 DTO에 담기
이제 전송받은 폼 데이터를 DTO에 담아본다. ArticleController에 가서 코드를 다음과 같이 수정한다.
① 폼에서 전송한 데이터를 createArticle() 메서드의 매개변수로 받아온다. DTO로 만든 클래스 이름이 ArticleForm이므로
ArticleForm 타입의 form 객체를 매개변수로 선언한다.
② 폼에서 전송한 데이터가 DTO에 잘 담겻는지 확인하기 위해 출력문을 추가한다. 출력문은 4장에서 로깅하는 방식으로 바꿀건데,
아직 로깅을 배우기 전이니 sysout문을 사용한다. form 객체의 toString()메서드를 호출해 출력.

3.2.7 입력 폼과 DTO 필드 연결하기
입력 폼에서 전송한 데이터를 DTO로 받기 위해 필드 2개, title과 content를 선언했다. 이 필드에 값이 들어가려면
new.mustache입력 폼에 필드명을 지정해줘야한다. 그래야 해당 입력 폼이 DTO 필드와 연결된다.
1. new.mustache에 다음과 같이 속성을 추가한다.
① 제목을 입력하는 <input>태그에 name="title"속성을 추가한다.
② 내용을 입력하는 <textarea> 태그에 name="content" 속성을 추가한다.
이렇게 DTO의 필드명과 동일한 이름을 name의 속성 값으로 써 주면 입력 폼에서 작성한 두 데이터가 DTO의 해당 필드와 연결된다.

2. 서버를 재시작한다. 브라우저를 새로 고침하고 제목은 abcd, 내용은 1234를 입력한 후 [Submit] 버튼을 클릭한다. 인텔리제이
하단 실행창에서 ArticleForm의 데이터가 title='abcd', content='1234'로 출력된 것을 확인할 수 있다.

지금까지 과정을 요약하면 다음과 같다.
1. 뷰 페이지 (new.mustache)를 만들고 <form>태그의 action 속성으로 데이터를 어디 보낼지 (action="/articles/create")
, method 속성으로 데이터를 어디에 보낼지 method="post"로 정의한다.

2. 컨트롤러(ArticleController.java)를 만들고 PostMapping방식으로 URL 주소를 연결(@PostMapping("articles/create"))한다.

3. 전송받은 데이터를 담아 둘 객체인 DTO(ArticleForm.java)를 만든다.

4. 컨트롤러에서 폼 데이터를 전송받아 DTO에 담는다.

3.3
DTO를 데이터베이스에 저장하기

지금까지 웹 브라우저에서 전송한 폼 데이터를 컨트롤러로 받아 오는 예제를 연습했다. 이 절에서는 받은 데이터를 데이터베이스에
저장하는 예제를 실습해 보겠다.

3.3.1
데이터베이스와 JPA
데이터베이스란 쉽게 말해 데이터를 관리하는 창고다. 쉽게 말하면 엑셀 파일과 비슷하다. 엑셀 파일을 보면 각 셀에 데이터를 저장한다.
DB의 모든 데이터도 행과 열로 구성된 테이블에 저장해 관리한다.

DB 프로그램은 MySQL, Oracle, MariaDB 등 다양한 종류가 있다. 여기서는 H2 DB를 사용하겠다.
DB에 데이터를 기록하려면 어떻게 해야 할까? 자바 언어로 "데이터 좀 기록해 줘." 라고 하면 안된다. DB는 자바 언어를 이해못한다.
스프링 부트는 자바 언어를 사용하지만 DB는 SQL이라는 언어를 사용하기 때문이다.

그러면 어떻게 DB에 자바로 명령을 내릴 수 있을까? 바로 JPA를 사용하면 된다. JPA란 자바 언어로 DB에 명령을 내리는 도구로,
데이터를 객체 지향적으로 관리할 수 있게 해준다.

JPA의 핵심도구로는 엔티티와 레파지토리가 있다.
엔티티(Entity): 자바 객체를 DB가 이해할 수 있게 만든 것으로, 이를 기반으로 테이블이 만들어진다.
레파지토리(Repository): 엔티티가 DB속 테이블에 저장 및 관리될 수 있게 하는 인터페이스다.

이번에는 앞에서 DTO로 받은 폼 데이터를 DB에 저장하는 예제를 해본다. 실습 순서는
1) DTO를 엔티티로 변환하기 -> 2) 레파지토리를 이용해 엔티티를 DB에 저장하기

3.3.2 DTO를 엔티티로 변환하기

1. 먼저 DTO를 엔티티로 변환해보자
① 현재 ArticleController에는 articles/create 주소로 URL 요청이 들어왔을 때 폼 데이터를 받아 출력하는 코드가 있다.
여기에다가 앞으로 할 작업을 주석으로 작성해 놓고 시작한다.
② DTO를 엔티티로 변환하기 위해 form객체의 toEntity()라는 메서드를 호출해서 그 반환값을 Article 타입의 article 엔티티에 저장한다.
근데 Article과 toEntity()에 빨간색 오류가 뜬다. 아직 Article클래스와 toEntity() 메서드를 만들지 않았기 때문

2. Article 클래스 코드를 작성해보자
① 이 클래스가 엔티티임을 선언하기 위해 @Entity어노테이션 추가, @Entity는 JPA에서 제공하는 어노테이션이다.
이 어노테이션이 붙은 클래스를 기반으로 DB에 테이블이 생성된다. 테이블 이름은 클래스 이름과 동일하게 Article로 생성

② DTO코드를 작성할 때와 같이 title, content필드를 선언한다. 두 필드도 DB에서 인식할 수 있게 @Column 어노테이션을 붙인다.
두 필드가 DB 테이블의 각 열(Column)과 연결된다.

③ 마지막으로 엔티티의 대표값을 넣는다. 대표값을 id로 선언하고 @Id 어노테이션을 붙인다. 이어서 @GeneratedValue 어노테이션도
붙여서 대표값을 자동으로 생성하게 한다. 예(1,2,3) 대표값은 사람으로 따지면 주민등록 번호와 같다. Article 엔티티 중에 제목과 내용이
같은 것이 있더라도 대표값 id로 다른 글임을 구분할 수 있다.

이렇게 해서 엔티티 클래스를 선언했다.

3. Article 객체의 생성 및 초기화를 위해 생성자를 추가한다. 코드 자동 생성 기능을 사용해 보겠다. content 필드 아래에서
마우스 오른쪽 버튼을 누르고 Generate -> Constructor를 선택 컨트롤을 누른 채 id:Long title:String content:String을 모두 선택 후 OK
이어서 toString() 메서드도 추가한다. 생성자 아래에서 마우스 오른쪽 버튼을 누르고 Generate -> toString()을 선택한다.
id:Long title:String content:String이 모두 선택 된 것을 확인하고 OK.

toEntity()메서드 추가하기
다음으로 toEntity()메서드를 만들어보겠다. toEntity()메서드는 DTO인 form객체를 엔티티 객체로 변환하는 역할을 한다.

1. 빨간색으로 표시된 toEntity()에 마우스를 올리고 잠시 기다리면 해당 메서드를 만들 수 있는 링크가 뜬다. 거기서 넣어라.

2. toEntity()메서드에서는 폼 데이터를 담은 DTO객체를 엔티티로 반환한다. (return new Article();)
전달값은 Article 클래스의 생성자 형식에 맞게 작성하면 된다. Article.java에서 생성자를 확인해보면, id, title, content를
매개변수로 하고있다. 아직 ArticleForm 객체에 id 정보는 없으므로 첫 번째 잘달값은 null, 두 번째 전달값은 title, 세 번째 전달값은
content를 입력한다.

3. ArticleController에 가보면 toEntity() 메서드의 오류표시가 사라진걸 볼 수 있다. 이렇게 해서 DTO를 엔티티로 변환하는 과정을 마쳤다.

3.3.3
레파지토리로 엔티티를 DB에 저장하기
다음으로 레파지토리로 엔티티를 DB에 저장한다. ArticleController에 레파지토리가 있다는 가정하에 코드를 작성한다.
① articleRepository.save() 메서드를 호출해 article엔티티를 저장한다. save()메서드는 저장된 엔티티를 반환하므로
이를 Article타입의 saved라는 객체에 받아온다. 그런데 articleRepository 부분에 오류가 뜬다.
이는 articleRepository 객체를 선언하지 않고 사용했기 때문

② 필드 선언부에 ArticleRepository 타입의 articleRepository 객체를 선언한다.
메모 놓친거 많다 2회독때 채워넣기

4장
롬복과 리팩터링

3장에서 폼 데이터를 DB에 저장해봤다. 실습을 진행하면서 DTO, 컨트롤러, 엔티티 등 많은 코드를 작성했다.
이장 에서는 코드를 간소화한다. -> 롬복을 소개

롬복 -> 코드를 간소화해주는 라이브러리
build.gradle에 롬복 의존성 추가
이건 별로 안어려우니 책만보고 하자.

5장
게시글 읽기: READ
3~4장에서는 웹 페이지에서 전송한 폼 데이터를 DB에 저장하는 데이터 생성 과정을 살폈다.
이 장에서는 DB에 저장된 데이터를 조회해 웹 페이지에 출력해보겠다.

오늘여기까지~
-----------------------------------------------
23/11/24 5장(200p)부터 진행~



















































































-----------------------------------------------
★★★★★★★★★★★★★★★★★★★★★★★★★★★★
Part.3 REST API와 테스트 코드 작성하기
★★★★★★★★★★★★★★★★★★★★★★★★★★★★
Part.4 댓글 CRUD 만들기
★★★★★★★★★★★★★★★★★★★★★★★★★★★★