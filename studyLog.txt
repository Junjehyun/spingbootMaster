Part.1 springBoot 개요

23/11/19
1장 스프링 부트 시작하기

환경설정:
proejct : Gradle - Groovy
Language: Java
Spring Boot: 3.1.0
Packaging: Jar
Java: 17

빌드 실행하려는데 안되네.. jdk버전 문제인거같음...
쇼핑몰을 끝내구 다시해야하는건가...흠....
43페이지 그림 1-26 프로젝트 열기성공 여기서부터 해라 
-----------------------------------------------
23/11/20
쇼핑몰 잠정 중단이니, jdk17 그냥 깔자!
음..해결된듯? 그럼 해보자..

1장.
스프링부트의 개발 환경 설정은 3단계를 거친다. 먼저 JDK(Java Development Kit, 자바 개발도구) 설치한다.
JDK는 자바 코드의 번역과 실행을 담당한다. 다음으로 IDE(인텔리제이나, 이클립스, vs스튜디오 등등..)준비한다.
마지막으로 스프링 부트 프로젝트를 만들어 "헬로 월드!"를 띄우면 모든 준비가 끝이다. 

그럼 준비가 끝났으니, 포트번호는 8080이고... 로컬호스트 들어가보자 
크롬에서 localhost:8080 들어가보자.. 이거는 스프링 부트가 실행중인 프로젝트가 실행된 서버에 접속하라는 뜻이다.
근데 whitelabe error page가 뜰것이다 왜 그러냐 ?

에러 화면이 뜨는거는 아직 웹 페이지를 만들지 않았기 때문이다. 여기에 "헬로 월드!"가 나올 수 있게 HTML을 만들어보겠다. 
파일명은 hello.html이라고 한다. 이 파일을 만들었다고 가정했을 때 주소 표시줄에 localhost:8080/hello.html이라고 입력하면
"헬로 월드!"가 나온다. 물론 아직은 에러페이지가 뜨지만. 

그럼 hello.html을 만들어보자. 프로젝트 탐색기의 src > main > resources > static 디렉토리에서 html파일 하나 생성한다. 
이름은 hello.html 그럼 바디태그안에 h1태그를 넣어서 헬로 월드!를 입력해보자.

그런 다음 localhost:8080/hello.html 해보자. 여전히 안된다. 이는 새로 만든 HTML파일을 서버에서 반영하지 않아서 그런거다. 
서버를 다시 한번 run하자 ! 그럼 된다. 
웹서비스는 클라이언트의 요청에 따른 서버의 응답으로 동작한다. 여기서 클라이언트란 서비스를 사용하는 컴퓨터를 말하고, 
서버는 서비스를 제공하는 컴퓨터를 말한다. "헬로 월드!"도 클라이언트의 요청에 따른 서버의 응답 결과였다. 웹 브라우저가
클라이언트로서 동작하고, 스프링 부트는 서버 역할을 수행했다. 클라이언트의 요청에 응답하려면 당연히 서버가 실행 중이어야 한다. 
서버 중지하면 당연히 응답하지 않는다. 

localhost:8080/hello.html 
서버에 접속할 때 사용하는 localhost:8080의 의미는 무엇일까? 또 그 뒤에 붙이는 hello.html은 어떻게 해석될까? 하나씩 살펴보자.

localhost : 실행 중인 서버의 주소 중 특별한 주소인 '내 컴퓨터'를 의미한다. 마치 내가 사는 집을 '우리 집'이라고 표현하는것과 같다.
localhost를 ip주소로 변경하면 127.0.0.1이된다.

8080: 포트번호를 의미한다. localhost가 우리집 이라면 8080은 방 번호에 해당한다. 클라이언트가 8080 번 방에 뭔가를 요청하는거다.
그리고 8080번 안에는 스프링 부트가 동작하고 있다. 앞에서 서버를 실행했을 때 "Tomcat started on port(s): 8080.. 이라는 메세지를
봤을 것이다. 톰캣이 8080 포트 안에서 수행되고 있다는 뜻이다. 톰캣은 웹 서버를 말하는데, 스프링 부트는 이 톰캣에 담겨 실행된다. 
참고로 스프링 부트는 8080에서 기본 실행된다. 포트번호는 필요에따라 변경 가능하다.

hello.html: localhost:8080으로만 접속하면 에러 페이지가 뜬다. 그 뒤에 hello.html을 붙여 접속해야 원하는 화면을 볼 수있다.
이는 웹 브라우저에서 요청한 hello.html 파일을 스프링 부트가 응답으로 보여줬기 때문이다.

여기서 hello.html은 서버에 요청하는 파일을 말한다. 웹 브라우저에서 localhost:8080/hello.html로 접속하면 내 컴퓨터의 8080번에서
수행되는 서버에 hello.html 파일을 요청한다. 이렇게 파일을 직접 지정할 경우 스프링 부트는 기본적으로 src > main > resources > static
디렉토리에서 파일을 찾는다. 그리고 찾은 HTML 코드를 응답으로 보낸다. 


그 다음 2장. 
MVC 패턴 이해와 실습에 대해 알아보자.
웹 페이지를 하나의 틀로 보고 변수에 따라 서로 다르게 출력하는 뷰 템플릿을 만들어 본다. 
그리고 뷰 템플릿을 실행하기 위해 역할을 분담해 동작하는 기법인 MVC패턴에 대해서도 알아보자.

보통 웹 사이트에 로그인 하면 "OO님 반갑습니다." 라는 문구를 볼 수 있다. 이런 문구는 어떻게 표시할까? 사용자 수만큼 웹 페이지가 
있는걸까? 만약 그렇다면 굉장히 귀찮을것이다. 새로운 사용자가 가입할 때마다 매번 새로운 웹 페이지를 만들어 줘야하니..

이런 괴로움에서 벗어나고 싶던 개발자들은 뷰 템플릿이란 기술을 만든다. 뷰 템플릿(view template)은 화면을 담당하는 기술로 , 
웹 페이지(view)를 하나의 틀로 만들고 여기에 변수를 삽입해 서로 다른 페이지로 보여준다. 

MVC패턴이란? 화면을 담당하는 뷰 템플릿은 간단히 '뷰'라고 한다. 뷰는 컨트롤러와 모델이라는 두 동료가 있다. 컨트롤러는 클라이언트의
요청에 따라 서버에서 이를 처리하는 역할을 하고, 모델은 데이터를 관리하는 역할을 한다. 이처럼 웹 페이지를 화면에 보여주고 (view), 
클라이언트의 요청에 받아 처리하고(controller), 데이터를 관리하는(model)역할을 나누는 기법을 MVC패턴 이라고 한다. 
Model-View-Control Pattern

뷰 템플릿 함 만들어보자.
src > main > resources를 펼치면 static과 templates가 있다. 뷰 템플릿은 templates디렉토리에 만들면 된다.
greetings.mustache로 만들자. src > main > resources > templates에 저장하면 스프링부트에서 자동으로 로딩한다.

TIP) 템플릿 엔진으로는 mustache, Thymeleaf, JSP 등이 있다. 

greetings.mustache라는 html파일 하나 만들었다. 이 페이지를 웹에서 보려면, 바로 뷰 템플릿의 동료인 컨트롤러와 모델을 이용해야한다.

controller 패키지 생성 후 -> FirstController 생성

package com.example.firstproject.controller;

// 컨트롤러 선언과 동시에 자동으로 임포트 됨.
import org.springframework.stereotype.Controller;

@Controller
// 이 클래스가 컨트롤러임을 선언하는 @Controller 어노테이션 작성한다. 이렇게 하면 Controller 클래스 패키지
// 가 자동으로 임포트 된다. 위에 있음.
public class FirstController {

    // 반환형이 문자열인 niceToMeetYou() 메서드를 선언한다.
    public String niceToMeetYou() {
        // 그리고 공백 문자열("")을 반환 하도록 return ""; 문을 추가한다. 이 반환문을 이용해 앞에서 만든
        // greetings.mustache 페이지를 반환하겠다.greetings.mustache 페이지를 반환하려면 파일 이름인 greetings
        // 만 반환값으로 적어주면 된다. 즉 return "greetings";로 적어 주면 서버가 알아서 templates 디렉토리에서
        // greetings.mustache 파일을 찾아 웹 브라우저로 전송한다.

        return "greetings"; // greetings.mustache 파일 반환
    }
}

여기까지 잘 했으면, 서버 다시 실행하자! 그리고 localhost:8080/greetings 했는데, 다시 화이트라벨 에러난다.
왜그럴까? FirstController에 가보면 niceToMeetYou() 메서드가 greetings.mustache를 반환하기 위해 return greetings;라고썼다.
그런데 빠진게 하나있다. 페이지(greetings.mustache)를 반환해 달라는 URL 요청을 접수하는 부분이다. -> @GetMapping

niceToMeetYou()메서드 앞에 @GetMapping을 추가한다. 그러면 자동으로 겟매핑 패키지가 임포트 된다.
겟매핑 주소안에는 /hi 주소를 넣어준다. @GetMapping("/hi")

다음, 모델 추가하기

앞에서 출력한 "홍팍님, 반갑습니다!" 에서 '홍팍'을 다른이름으로 바꾸고 싶다면 어떻게 해야하나?
예를들어 '홍팍' 대신 username이라는 변수를 써서, 어떨때는 '홍팍', 어떨때는 '홍어삼함' 이라고 나오게 만드는거.

이럴 땐 머스테치 문법을 사용해 뷰 템플릿 페이지에 변수를 삽입한다. 변수명을 적고 두 겹의 중괄호 ({{}})로 감싼다.

cf) {{변수명}}

greetings.mustache에서 홍팍님을 {{username}}님 이라고 수정한다. 이렇게 이름 대신 들어갈 변수명을 쓰면 변숫값에 따라
결과가 그때그때 다르게 출력된다. 단순히 "홍팍님, 반갑습니다!" 라고 출력됐던 뷰 페이지가 "OO님, 반갑습니다!"로 템플릿화 되는거다.

서버 재시작하고 localhost:8080/hi에 접속해봐라. 그럼 내부에서 에러가 난다. 추가한 username이라는 변수를 찾을수 없기 때문이다.
에러를 해결하기 위해 모델을 사용하겠다! 모델은 MVC 패턴에서 데이터를 관리하는 역할을 한다.

모델은 컨트롤러의 메서드에서 매개변수로 받아온다. FirstController로 가서 niceToMeetYou() 메서드에 Model 타입의 model 매개변수를
추가해라. 그러면 Model 클래스 패키지가 자동으로 임포트 된다.

그 다음 Model 클래스 패키지가 임포트 됐다면, 모델을 통해 변수를 등록 할 수 있다. 모델에서 변수를 등록할 때는 addAttribute() 메서드를
사용.

 model.addAttribute("username", "홍어삼합"); -> 입력하고 다시 서버 재실행하고 브라우저 봐라.
잘 출력됨.

지금까지 한거 정리!

뷰 페이지 만들기 (greetings.mustache) -> 컨트롤러 만들기 (FirstController.java) -> 컨트롤러에서 뷰 페이지 반환하기 (return "greetings";)
-> 뷰 페이지에 변수 삽입하기 {{username}} -> 컨트롤러에 모델 추가하기 niceToMeetYou(Model model) -> 모델에서 변수 등록하기 model.addAttribute("username", "홍팍");

그 다음 MVC의 역할과 실행 흐름 이해하기

웹 서비스는 클라이언트의 요청에 대한 서버의 응답으로 동작한다. 이때 스프링 부트는 서버의 역할을 한다.
서버는 앞에서 배웠듯이 모델,뷰,컨트롤러가 유기적으로 역할을 분담해 클라이언트의 요청을 처리한다. 식당에서 웨이터가 주문을 받고, 주방장이 요리를 하고,
식재료 담당자가 재료를 준비하는 것처럼 컨트롤러가 클라이언트의 요청을 받고, 뷰가 최종 페이지를 만들고, 모델이 최종 페이지에 쓰일 데이터를 뷰에 전달한다.

앞에서 뷰 템플릿 페이지 (greetings.mustache)가 어떤 과정을 거쳐 출력되는지 알아봤으니 이번에는 모델, 뷰, 컨트롤러 관점에서 그 과정을 분석해보자.

아까 /hi 페이지의 실행 흐름.
localhost:8080/hi에 접속해 결과를 다시 한번 확인해 봅시다. "hongpark님, 반갑습니다!"가 잘 출력 된다. 이렇게 클라이언트가 localhost:8080/hi라고 요청하면
서버 내부에서는 컨트롤러가 요청을 받아 처리한다.

FirstController.java 코드를 보며 컨트롤러의 동작을 이해해보자. (책 89쪽 오늘 여기까지 낼 90패이지부터)
-----------------------------------------------
23/11/21 90p 시작.

이번에는 /bye 페이지를 만들어보자.
localhost:8080/bye로 요청을 받을 때, "XX님, 다음에 또 만나요!"를 출력해보겠다. /bye 요청을 받아 줄 컨트롤러를 새롭게 만들어도
되지만, 이번에도 그냥 FirstController를 사용해 보겠다.

1. 컨트롤러는 @Controller 내부에 @GetMapping 어노테이션을 통해 클라이언트의 요청을 받는다.
2. /bye 요청을 처리할 seeYouNext() 메서드를 만든다.
3. 반환값은 요청에 따라 보여 줄 뷰 템플릿 페이지를 적는데, 아직 뷰 템플릿 페이지를 만들지 않았으므로, 임의로 return "goodbye";라고 적음.
4. 그런데 사용자 이름을 그때그때 변경하고 싶다. XX님 부분을 변수로 처리해보자. 아까 했던것 처럼!! 변수명은 nickname으로 한다.
<h1>{{nickname}}님, 다음에 또 만나요!<h1>으로 코드를 수정한다.
5. 뷰 템플릿 페이지에서 변수(nickname)를 이용하려면 이 페이지를 반환하는 컨트롤러의 메서드 (seeYouNext)에 변수를 등록해야함.
모델을 통해서, 컨트롤러로 가서 다음과 같이 코드를 추가한다.
(1) seeYouNext() 메서드의 매개변수로 model 객체를 받아 온다.
(2) model.addAttribute() 메서드로 등록할 변수명과 변숫값을 적어준다.

정리하자면 컨트롤러는 클라이언트의 요청을 @GetMapping("/bye")로 받는다. 그리고 return값으로 goodbye.mnustache를 반환한다.
이때 "nickname" 이라는 변수를 등록하고, "홍길동" 이라는 값을 연결해 goodbye.mustache 파일에서 사용할 수 있게 한다.

이렇게 해서 /hi 페이지와 /bye 페이지의 출력 과정에서 모델, 뷰, 컨트롤러의 역할과 실행 흐름을 살펴봤다.

/hi , /bye 페이지에 헤더-푸터 레이아웃을 적용해보자. 좀 꾸며야 할꺼 아이가

bootstrap으로 활용해보겠다. v5.0.2로 해라.
Starter Template내용 다 복사해서 greetings.mustache에 다 붙여넣음.
body태그안에
navigation, content, site info 순으로 주석 달아서 적어줌.
콘텐트 영역을 만들었으니 헤더 영역에 네비게이션 바를 추가해보자! 부트스트랩 홈페이지가서 다시 v5.0.2짜리 검색창에서 navbar를 검색!

일단 간단하게 적용했다.
/hi는 끝 그담에 /bye까지 하고 오늘 끝내자.
/hi랑 똑같이 해주는거야 고고

헤더, 푸터 영역을 변수화해 사용해보도록 한다. 각각 영역을 발췌해 템플릿 파일로 만들자.
코드의 가독성이 훨씬 좋다.

templates > layouts > footer.mustache, header.mustache 각각 만들어라.
greetings.mustache 코드에서 상단 내비게이션 바 부분을 발췌해 header.mustache로 만들어보자.
1행부터 콘텐트 영역의 바로 윗줄 <!DOCTYPE HTML>~</nav>까지 선택해 자른 후 header.mustache 파일에 붙인다.
1행의 <!DOCTYPE HTML>~</nav>까지 잘 붙여넣었는지 확인한다.

마찬가지로 greetings 코드의 푸터영역 <!-- site info -->~</html>도 잘라낸 후 footer.mustache 파일에 붙여넣자.

greetings.mustache 코드의 컨텐트 영역 아래에 {{>layouts/footer}}를 작성해 템플릿화한 footer.mustache 파일을 변수로 가져오자.

최종적으로 greetings.mustache 코드가 매우 짧아졌다. 위쪽에 헤더파일이 아래쪽에 푸터 파일이 들어가있다.
이제 이 페이지를 보는 사람도 "여기서 핵심 내용(content)이 뭐야?" 라는 질문에 답할 수 있다. 딱 4줄짜리 코드만 보니까
아~ 인사하는 페이지구나 한다.

이렇게 해서 머스테치 뷰 템플릿으로 레이아웃을 구성해봤다. 결과가 잘 나오는지 확인해보자. 다시 로컬호스트 새로고침 해서
확인해보자. -> 잘됐다.

goodbye.mustache 파일도 다음과 같이 해라.

1. 콘텐트 영역 h1태그를 제외하고 기존 코드를 지운 후 헤더 템플릿과 푸터 템플릿을 삽입한다.
2. 콘텐트 영역을 div로 감싸고 부트스트랩의 class속성을 적용해 완성한다.

똑같이 잘됐다. 대단한데 ?

마무리.

1. 뷰 템플릿 : 웹 페이지를 하나의 틀로 만들고, 여기에 변수를 삽입해 서로 다른 페이지로 보여주는 기술
2. MVC 패턴 : 웹 페이지를 화면에 보여 주고(view), 클라이언트의 요청을 받아 처리하고(Controller), 데이터를 관리하는(Model) 역할을
영역별로 나누어 하는 기법을 말한다.
3. 뷰 템플릿 생성 위치
뷰 템플릿은 src > main > resource > templates 디렉토리에 만든다. 머스테치 뷰 템플릿의 확장자는 .mustache다.
4. 컨트롤러 생성 위치 : 컨트롤러는 src > main > java > 기본 패키지안에 컨트롤러 패키지를 만든 후 자바 클래스 파일을 생성하는 방식이다.
확장자는 .java다
5. 모델에 변수를 등록하는 방법 : 모델은 컨트롤러의 메서드에서 매개변수로 받아온다. 모델에서 변수를 등록할 때는 addAttribute() 메서드를 사용.
6. 헤더-푸터 레이아웃 : 가장 기본이 되는 페이지의 레이아웃으로 헤더 영역에는 사이트 안내를 위한 내비게이션을 넣고, 푸터 영역에는 사이트 정보등을
넣는다. 그리고 두 영역 사이에 콘텐트 영역에는 사용자가 볼 핵심 내용을 배치한다.
7. 부트스트랩 : 웹 페이지를 쉽게 만들 수 있도록 각종 레이아웃, 버튼, 입력창 등 디자인을 미리 만들어 놓은 것이다. 사용자는 코드를 가져와
사용하기만 하면 되므로 편리하게 웹 페이지를 만들 수 있다.
8. 레이아웃 템플릿 생성과 적용 : 레이아웃 템플릿 파일은 src > main > resource > templates 디렉토리에 만든다. (본문에서는 파일 관리를 편리하게
하기 위해 layouts 디렉토리를 추가한 후 만든다.)
**중요** 레이아웃 템플릿을 삽입할 때는 원하는 위치에서 {{>파일경로/파일명}} 형식으로 작성!

Part1. 스프링 부트 개요 끝! 생각보다 빨랐다. 하루만에 끝
★★★★★★★★★★★★★★★★★★★★★★★★★★★★
Part.2 게시판 CRUD 만들기

23/11/22
3장. 게시판 만들고 새 글 작성하기 시작하면된다.
책 기준 117쪽..
-----------------------------------------------









































































-----------------------------------------------
★★★★★★★★★★★★★★★★★★★★★★★★★★★★
Part.3 REST API와 테스트 코드 작성하기
★★★★★★★★★★★★★★★★★★★★★★★★★★★★
Part.4 댓글 CRUD 만들기
★★★★★★★★★★★★★★★★★★★★★★★★★★★★